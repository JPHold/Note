[TOC]

# 创建服务

## 镜像在私有注册库中
**要带上--with-registry-auth配置**
1. 先登录
```
docker login registry.example.com
```

2. 带上注册库的信息
```
 docker service  create --with-registry-auth --name my_service registry.example.com/acme/my_image:latest
```

# 更新服务
* 想对外发，可更新对外发布端口配置
`docker service update --publish-add 80 xxxServiceName`

# 删除服务
`docker service remove xxxServiceName`

# 配置清单

## 运行环境
-   使用`--env`标志的环境变量
-   使用`--workdir`标志的容器内的工作目录
-   使用`--user`标志的用户名或 UID

```
 docker service create --name helloworld \
  --env MYVAR=myvalue \
  --workdir /tmp \
  --user my_user \
  alpine ping docker.com
```

## 更新服务的执行命令
```
docker service update --args "ping docker.com" helloworld
```

## 指定镜像
* 创建服务时的指定
```
docker service create --name="myservice" ubuntu:latest
```

* 更新服务时的指定
`docker service update --image xxxImage xxxServiceName`

## 发布端口
因为一个节点会运行服务的多个任务实例，需要提供负载能力将请求路由到这些任务中，提供了两种方式：1、swarm提供的路由网络 2、不具备内部路由，直接对接外部路由

### swarm路由网络
每个工作节点都监听对外的端口，但不是每个节点都运行任务实例；这不会有问题，因为路由网络会将请求路由真正执任务的节点

### 对接外部路由
使用`--publish mode=host`这个参数，工作节点上一个对外端口只对应一个任务端口，并不能像swarm路由网络那样，在内部将外部端口过来的请求路由到某个任务上，需要自己控制；很像以前的方式：启动多个容器，每个容器的对外端口都不一样。

**注意：**
1. `--publish mode=host`与`--publish published=xxxPort`，因为指定了对外端口，加上缺少内部路由到任务的管理，所以只能一个对外端口对应一个内部任务端口；导致每个工作节点只能运行一个任务；**解决办法：去掉published，则会随机发布对外端口，但这就很不利于外部负载均衡的计算，因为我不知道你的端口是啥，端口始终在变化**

2. 如果不使用`--mode=global`配置，则很难知道在哪些工作节点运行任务，外部负载均衡很难计算

**例子（每个工作节点都运行任务+固定对外端口）：**
```
docker service create \
  --mode global \
  --publish mode=host,target=80,published=8080 \
  --name=nginx \
  nginx:latest
```

## overlay网络
* 创建
`docker network create --driver overlay my-network`

* 创建服务时指定网络
```
docker service create \
  --replicas 3 \
  --network my-network \
  --name my-web \
  nginx
```

* 更新服务时指定网络
`docker service update --network-add my-network my-web`

* 移除
`docker service update --network-rm my-network my-web`

## 服务布置
包含如下内容：
* 任务副本数
* 