[TOC]

# 三种命令启动
## CMD(容器执行)
* Dockerfile多个CMD，以最后一个为准
* 如果启动容器时指定启动命令，也会覆盖Dockerfile的CMD命令
	`docker run xxxImage xxxCommand`，xxxCommand会覆盖
	
* 存在[[#ENTRYPOINT]]，则会将CMD的参数当做ENTRYPOINT的参数
```
FROM redis
CMD ["/usr"]
ENTRYPOINT ["/bin/ls"]
```
启动后：`docker run --rm  sum_cmd_entrypoint`
![[Pasted image 20210728154452.png]]

* 在docker run最后面的字符串，这时不是命令，而是当做ENTRYPOINT的参数
![[Pasted image 20210728155207.png]]
![[Pasted image 20210728155247.png]]

## ENTRYPOINT(容器执行)
* docker run --entrypoint=""替换掉Dockerfile的ENTRYPOINT命令

## RUN(镜像执行)

# 启动方式

## 调用二进制文件
比如redis，使用`CMD ./redis-server`

## 调用脚本
跟[[#调用二进制文件]]相似
同样以redis为例，将./redis-server写进脚本，然后调用脚本即可
**需要两步**
1. 将脚本复制到容器内部
	`ADD xxx.sh /xxxDir/xxx.sh`
2. 调用
	`CMD ["/xxxDir/xxx.sh"]`
	
## 显示使用文档
**不启动任何应用程序，只是打印出使用说明**
这篇文章使用了(待整理)[s2i](https://github.com/openshift/source-to-image)[[2021-08(31)]][[高效]]（镜像构建器，直接从源代码到镜像的快速打包，无需写Dockerfile）

## systemd作为服务启动
需要安装systemd：apt-install systemd
**需要两步**
1. `RUN systemctl enable rsyslog` 通知systemd启用该服务
2. `RUN /usr/sbin/init` 交给init进程处理剩余工具

# source-to-image(s2i)
## 安装
**因为s2i是用golang语言写的，因此需要先安装golang环境**

### 安装golang
根据官方文档即可安装，很简单
[下载](https://golang.google.cn/dl/)
[安装](https://golang.google.cn/doc/install)

### 安装s2i
[下载](https://github.com/openshift/source-to-image/releases/tag/v1.3.1)
[安装](https://github.com/openshift/source-to-image#for-linux)

## hello-world
`s2i build https://github.com/openshift/ruby-hello-world centos/ruby-25-centos7 test-ruby-app`

```
[root@localhost hello]# s2i build https://github.com/openshift/ruby-hello-world centos/ruby-25-centos7 test-ruby-app
---> Installing application source ...
---> Building your Ruby application from source ...
---> Running 'bundle install --retry 2 --deployment --without development:test' ...
Fetching gem metadata from https://rubygems.org/........
Fetching rake 13.0.3
Installing rake 13.0.3
Fetching concurrent-ruby 1.1.8
Installing concurrent-ruby 1.1.8
Fetching i18n 1.8.9
Installing i18n 1.8.9
Fetching minitest 5.14.4
Installing minitest 5.14.4
Fetching tzinfo 2.0.4
Installing tzinfo 2.0.4
Fetching zeitwerk 2.4.2
Installing zeitwerk 2.4.2
Fetching activesupport 6.1.3.2
Installing activesupport 6.1.3.2
Fetching activemodel 6.1.3.2
Installing activemodel 6.1.3.2
Fetching activerecord 6.1.3.2
Installing activerecord 6.1.3.2
Using bundler 1.16.1
Fetching ruby2_keywords 0.0.4
Installing ruby2_keywords 0.0.4
Fetching mustermann 1.1.1
Installing mustermann 1.1.1
Fetching mysql2 0.5.3
Installing mysql2 0.5.3 with native extensions
Fetching rack 2.2.3
Installing rack 2.2.3
Fetching rack-protection 2.1.0
Installing rack-protection 2.1.0
Fetching tilt 2.0.10
Installing tilt 2.0.10
Fetching sinatra 2.1.0
Installing sinatra 2.1.0
Fetching sinatra-activerecord 2.0.22
Installing sinatra-activerecord 2.0.22
Fetching webrick 1.7.0
Installing webrick 1.7.0
Bundle complete! 7 Gemfile dependencies, 19 gems now installed.
Gems in the groups development and test were not installed.
Bundled gems are installed into `./bundle`
---> Cleaning up unused ruby gems ...
Running `bundle clean --verbose` with bundler 1.16.1
Frozen, using resolution from the lockfile
Build completed successfully
```
![[Pasted image 20210803165137.png]]

## 制作构建器镜像

### JAVA
s2i文档描述：对于JAVA这种编译语言，最好分成两个镜像(一个负责构建编译、另一个负责启动)完成整个构建，这样的好处是无需将构建环境的依赖留在最终应用容器，导致镜像过大。这次先使用一个镜像一步到位

#### 准备MAVEN容器
直接使用[maven官方的镜像](https://registry.hub.docker.com/_/maven?tab=tags&page=1&ordering=last_updated)
`docker pull maven:3.8.1-amazoncorretto-8`

**包含了JDK环境，版本是1.8**

#### 创建构建器镜像模板
`s2i create hello-make-s2i makeS2i`
第一个参数是容器的名称
第二个参数是工作目录名称
**执行后会在当前目录，创建makeS2i目录，结构如下：**
![[Pasted image 20210804185601.png]]

#### 开始编写构建规则
[参考这个](https://gitee.com/waret/s2i-java/tree/master/1.8-maven/.s2i/bin)
关注s2i/bin目录下的assemble文件和run文件
**这里简单介绍下文件的用处：**
1. assemble
负责将源代码编译打包

2. run
构建应用容器完毕后的应用启动命令，可以是启动tomcat，也可以是java -jar

3. save-artifacts
保存版本打包，可用于回退版本

4. usage
应用的帮助文档，比如如何为启动，使用啥的

----
##### 编写Dockerfile
1. 修改基础镜像

2. 配置maven执行命令

3. 指定s2i脚本的位置
必须指定，不然s2i build时会报错
![[Pasted image 20210804174902.png]]

4. 拷贝主机的s2i脚本到容器内部

**内容如下：**
```Dockerfile
# hello-make-s2i
FROM maven:3.8.1-amazoncorretto-8

# TODO: Put the maintainer name in the image metadata
# LABEL maintainer="Your Name <your@email.com>"

# TODO: Rename the builder environment variable to inform users about application you provide them
# ENV BUILDER_VERSION 1.0
ENV MAVEN_BUILD_CMD="clean install" 

# TODO: Set labels used in OpenShift to describe the builder image
#LABEL io.k8s.description="Platform for building xyz" \
#      io.k8s.display-name="builder x.y.z" \
#      io.openshift.expose-services="8080:http" \
#      io.openshift.tags="builder,x.y.z,etc."
LABEL io.openshift.s2i.scripts-url="image://usr/libexec/s2i"

# TODO: Install required packages here:
# RUN yum install -y ... && yum clean all -y

# TODO (optional): Copy the builder files into /opt/app-root
# COPY ./<builder_folder>/ /opt/app-root/

# TODO: Copy the S2I scripts to /usr/libexec/s2i, since openshift/base-centos7 image
# sets io.openshift.s2i.scripts-url label that way, or update that label
COPY ./s2i/bin/ /usr/libexec/s2i

# TODO: Drop the root user and make the content of /opt/app-root owned by user 1001
#RUN chown -R 1001:1001 /opt/app-root

# This default user is created in the openshift/base-centos7 image
#USER 1001

# TODO: Set the default port for applications built using this image
# EXPOSE 8080

# TODO: Set the default CMD for the image
CMD ["/usr/libexec/s2i/usage"]
```
![[Pasted image 20210804192413.png]]

##### 编写assemble
完成拷贝源代码、构建打包源代码成jar、将jar改名
```shell
#!/bin/bash -e
#
# S2I assemble script for the 'hello-make-s2i' image.
# The 'assemble' script builds your application source so that it is ready to run.
#
# For more information refer to the documentation:
#       https://github.com/openshift/source-to-image/blob/master/docs/builder_image.md
#

# If the 'hello-make-s2i' assemble script is executed with the '-h' flag, print the usage.
if [[ "$1" == "-h" ]]; then
        exec /usr/libexec/s2i/usage
fi

# Restore artifacts from the previous build (if they exist).
#
if [ "$(ls /tmp/artifacts/ 2>/dev/null)" ]; then
  echo "---> Restoring build artifacts..."
  shopt -s dotglob
  mv /tmp/artifacts/* ./
  shopt -u dotglob
fi

echo "---> Installing application source..."
cp -rf /tmp/src/. ./

echo "---> Building application from source..."
# TODO: Add build steps for your application, eg npm install, bundle install, pip install, etc.

# maven打包
echo "---> Building application from source..."
MAVEN_BUILD_CMD=${MAVEN_BUILD_CMD:-"install"}
echo "--> # MAVEN_BUILD_CMD = $MAVEN_ARGS"
if [ -f "mvnw" ]; then
  echo "---> Building application with maven wrapper..."
  ./mvnw $MAVEN_BUILD_CMD
else
  echo "---> Building application with installed maven..."
  mvn $MAVEN_BUILD_CMD
fi

ARTIFACT_DIR=${ARTIFACT_DIR:-target}
echo "--> # ARTIFACT_DIR = $ARTIFACT_DIR"
echo "---> Rename artifact $(find $ARTIFACT_DIR -name *.jar)"
result_file=$(find $ARTIFACT_DIR -name *.jar)
if [ -z "$result_file" ]; then
  echo "---> Build file could not be found"
  exit 1
fi
mv $result_file app.jar
```

##### 编写run
完成应用启动
```
#!/bin/bash -e
#
# S2I run script for the 'hello-make-s2i' image.
# The run script executes the server that runs your application.
#
# For more information see the documentation:
#       https://github.com/openshift/source-to-image/blob/master/docs/builder_image.md
#
ARTIFACT_DIR=${ARTIFACT_DIR:-target}
echo "---> Starting Java application"
echo "--> # APP_FILE = $APP_FILE"
echo "--> # JAVA_OPTS = $JAVA_OPTS"
APP_FILE="${APP_FILE:-app.jar}"
if [[ -f "$APP_FILE" ]]; then
  echo "---> APP_FILE found"
  echo "---> Running application from jar (java $JAVA_OPTS -jar $APP_FILE) ..."
  java $JAVA_OPTS -jar $APP_FILE
else
  echo "---> Running application from jar (java $JAVA_OPTS -jar $(find $ARTIFACT_DIR -name *.jar)) ..."
  java $JAVA_OPTS -jar `find $ARTIFACT_DIR -name *.jar`
fi
```

#### 生成构建器镜像
1. 回到顶层目录
![[Pasted image 20210804220524.png]]

2. 执行make build
执行的是Makefile，根据后面的参数进行不同操作。
这里是build，docker打包
```Makefile
IMAGE_NAME = hello-make-s2i

.PHONY: build
build:
        docker build -t $(IMAGE_NAME) .

.PHONY: test
test:
        docker build -t $(IMAGE_NAME)-candidate .
        IMAGE_NAME=$(IMAGE_NAME)-candidate test/run
```

3. 查看打好的构建器镜像
![[Pasted image 20210804220923.png]]

#### 构建应用镜像
我这次先一步到位：编译和运行都在一个构建器镜像完成

1. 切换到源代码目录
![[Pasted image 20210804221400.png]]

2. 执行构建
这里操作的是本地代码库
`s2i build . hello-make-s2i:latest s2i-java-hello-app`
build后面的参数，说明如下：
第一个参数：代码目录
第二个参数：构建器镜像的tag名称[[#生成构建器镜像]]
第三个参数：应用镜像的tag名称

3. 查看构建好的应用镜像
![[Pasted image 20210804222226.png]]

#### 启动应用
![[Pasted image 20210804222402.png]]

## 后期实操
### maven要将本地repository挂载到主机，减少构建器镜像重复下包

### 要将编译和运行分成两个镜像，不要将编译环境带到应用镜像中，减少包大小
利用Docker提供的多阶段构建，Dockerfile可拥有多个FROM，然后后面FROM的操作可以使用前面FROM的产物