[TOC]

# 三种命令启动
## CMD(容器执行)
* Dockerfile多个CMD，以最后一个为准
* 如果启动容器时指定启动命令，也会覆盖Dockerfile的CMD命令
	`docker run xxxImage xxxCommand`，xxxCommand会覆盖
	
* 存在[[#ENTRYPOINT]]，则会将CMD的参数当做ENTRYPOINT的参数
```
FROM redis
CMD ["/usr"]
ENTRYPOINT ["/bin/ls"]
```
启动后：`docker run --rm  sum_cmd_entrypoint`
![[Pasted image 20210728154452.png]]

* 在docker run最后面的字符串，这时不是命令，而是当做ENTRYPOINT的参数
![[Pasted image 20210728155207.png]]
![[Pasted image 20210728155247.png]]

## ENTRYPOINT(容器执行)
* docker run --entrypoint=""替换掉Dockerfile的ENTRYPOINT命令

## RUN(镜像执行)

# 启动方式

## 调用二进制文件
比如redis，使用`CMD ./redis-server`

## 调用脚本
跟[[#调用二进制文件]]相似
同样以redis为例，将./redis-server写进脚本，然后调用脚本即可
**需要两步**
1. 将脚本复制到容器内部
	`ADD xxx.sh /xxxDir/xxx.sh`
2. 调用
	`CMD ["/xxxDir/xxx.sh"]`
	
## 显示使用文档
**不启动任何应用程序，只是打印出使用说明**
[[#source-to-image s2i Docker重点]]

## systemd作为服务启动
需要安装systemd：apt-install systemd
**需要两步**
1. `RUN systemctl enable rsyslog` 通知systemd启用该服务
2. `RUN /usr/sbin/init` 交给init进程处理剩余工具

# source-to-image(s2i)[[Docker重点]]
## 安装
**因为s2i是用golang语言写的，因此需要先安装golang环境**

### 安装golang(版本：go1.16.6.linux-amd64)
根据官方文档即可安装，很简单
[下载](https://golang.google.cn/dl/)
[安装](https://golang.google.cn/doc/install)

### 安装s2i(版本：source-to-image-v1.3.1-a5a77147-linux-amd64)
[下载](https://github.com/openshift/source-to-image/releases/tag/v1.3.1)
[安装](https://github.com/openshift/source-to-image#for-linux)

## hello-world
`s2i build https://github.com/openshift/ruby-hello-world centos/ruby-25-centos7 test-ruby-app`

```
[root@localhost hello]# s2i build https://github.com/openshift/ruby-hello-world centos/ruby-25-centos7 test-ruby-app
---> Installing application source ...
---> Building your Ruby application from source ...
---> Running 'bundle install --retry 2 --deployment --without development:test' ...
Fetching gem metadata from https://rubygems.org/........
Fetching rake 13.0.3
Installing rake 13.0.3
Fetching concurrent-ruby 1.1.8
Installing concurrent-ruby 1.1.8
Fetching i18n 1.8.9
Installing i18n 1.8.9
Fetching minitest 5.14.4
Installing minitest 5.14.4
Fetching tzinfo 2.0.4
Installing tzinfo 2.0.4
Fetching zeitwerk 2.4.2
Installing zeitwerk 2.4.2
Fetching activesupport 6.1.3.2
Installing activesupport 6.1.3.2
Fetching activemodel 6.1.3.2
Installing activemodel 6.1.3.2
Fetching activerecord 6.1.3.2
Installing activerecord 6.1.3.2
Using bundler 1.16.1
Fetching ruby2_keywords 0.0.4
Installing ruby2_keywords 0.0.4
Fetching mustermann 1.1.1
Installing mustermann 1.1.1
Fetching mysql2 0.5.3
Installing mysql2 0.5.3 with native extensions
Fetching rack 2.2.3
Installing rack 2.2.3
Fetching rack-protection 2.1.0
Installing rack-protection 2.1.0
Fetching tilt 2.0.10
Installing tilt 2.0.10
Fetching sinatra 2.1.0
Installing sinatra 2.1.0
Fetching sinatra-activerecord 2.0.22
Installing sinatra-activerecord 2.0.22
Fetching webrick 1.7.0
Installing webrick 1.7.0
Bundle complete! 7 Gemfile dependencies, 19 gems now installed.
Gems in the groups development and test were not installed.
Bundled gems are installed into `./bundle`
---> Cleaning up unused ruby gems ...
Running `bundle clean --verbose` with bundler 1.16.1
Frozen, using resolution from the lockfile
Build completed successfully
```
![[Pasted image 20210803165137.png]]

## 制作构建器镜像

### JAVA
s2i文档描述：
> 对于JAVA这种编译语言，最好分成两个镜像(一个负责构建编译、另一个负责启动)完成整个构建，这样的好处是无需将构建环境的依赖留在最终应用容器，导致镜像过大。

#### 编译+启动一体式的构建器镜像
(当前目录包含本次实践的所有资料)[[Docker/附件/source_to_image/makeS2i/README]]
##### 准备MAVEN镜像
直接使用[maven官方的镜像](https://registry.hub.docker.com/_/maven?tab=tags&page=1&ordering=last_updated)
`docker pull maven:3.8.1-amazoncorretto-8`

**包含了JDK环境，版本是1.8**

##### 创建构建器镜像模板
`s2i create hello-make-s2i makeS2i`
第一个参数是容器的名称
第二个参数是工作目录名称
**执行后会在当前目录，创建makeS2i目录，结构如下：**
![[Pasted image 20210804185601.png]]

##### 开始编写构建规则
[参考这个](https://gitee.com/waret/s2i-java/tree/master/1.8-maven/.s2i/bin)
关注s2i/bin目录下的assemble文件和run文件
**这里简单介绍下文件的用处：**
1. assemble
负责将源代码编译打包

2. run
构建应用容器完毕后的应用启动命令，可以是启动tomcat，也可以是java -jar

3. save-artifacts
保存版本打包，可用于回退版本

4. usage
应用的帮助文档，比如如何启动，使用啥的

----
###### 编写Dockerfile
1. 修改基础镜像

2. 配置maven执行命令

3. 指定s2i脚本的位置
必须指定，不然s2i build时会报错
![[Pasted image 20210804174902.png]]

4. 拷贝主机的s2i脚本到容器内部

**内容如下：**
```Dockerfile
# hello-make-s2i
FROM maven:3.8.1-amazoncorretto-8

# TODO: Put the maintainer name in the image metadata
# LABEL maintainer="Your Name <your@email.com>"

# TODO: Rename the builder environment variable to inform users about application you provide them
# ENV BUILDER_VERSION 1.0
ENV MAVEN_BUILD_CMD="clean install -DskipTests" 

# TODO: Set labels used in OpenShift to describe the builder image
#LABEL io.k8s.description="Platform for building xyz" \
#      io.k8s.display-name="builder x.y.z" \
#      io.openshift.expose-services="8080:http" \
#      io.openshift.tags="builder,x.y.z,etc."
LABEL io.openshift.s2i.scripts-url="image://usr/libexec/s2i"

# TODO: Install required packages here:
# RUN yum install -y ... && yum clean all -y

# TODO (optional): Copy the builder files into /opt/app-root
# COPY ./<builder_folder>/ /opt/app-root/

# TODO: Copy the S2I scripts to /usr/libexec/s2i, since openshift/base-centos7 image
# sets io.openshift.s2i.scripts-url label that way, or update that label
COPY ./s2i/bin/ /usr/libexec/s2i

# TODO: Drop the root user and make the content of /opt/app-root owned by user 1001
#RUN chown -R 1001:1001 /opt/app-root

# This default user is created in the openshift/base-centos7 image
#USER 1001

# TODO: Set the default port for applications built using this image
# EXPOSE 8080

# TODO: Set the default CMD for the image
CMD ["/usr/libexec/s2i/usage"]
```
![[Pasted image 20210804192413.png]]

###### 编写assemble
完成拷贝源代码、构建打包源代码成jar、将jar改名
```shell
#!/bin/bash -e
#
# S2I assemble script for the 'hello-make-s2i' image.
# The 'assemble' script builds your application source so that it is ready to run.
#
# For more information refer to the documentation:
#       https://github.com/openshift/source-to-image/blob/master/docs/builder_image.md
#

# If the 'hello-make-s2i' assemble script is executed with the '-h' flag, print the usage.
if [[ "$1" == "-h" ]]; then
        exec /usr/libexec/s2i/usage
fi

# Restore artifacts from the previous build (if they exist).
#
if [ "$(ls /tmp/artifacts/ 2>/dev/null)" ]; then
  echo "---> Restoring build artifacts..."
  shopt -s dotglob
  mv /tmp/artifacts/* ./
  shopt -u dotglob
fi

# TODO: Add build steps for your application, eg npm install, bundle install, pip install, etc.

# maven打包
cd /tmp/src/
echo "---> Building application from source..."
MAVEN_BUILD_CMD=${MAVEN_BUILD_CMD:-"install"}
echo "--> # MAVEN_BUILD_CMD = $MAVEN_ARGS"
if [ -f "mvnw" ]; then
  echo "---> Building application with maven wrapper..."
  ./mvnw $MAVEN_BUILD_CMD
else
  echo "---> Building application with installed maven..."
  mvn $MAVEN_BUILD_CMD
fi

# 在target目录找到打好的jar包，并改名为app.jar
ARTIFACT_DIR=${ARTIFACT_DIR:-target}
echo "--> # ARTIFACT_DIR = $ARTIFACT_DIR"
echo "---> Rename artifact $(find $ARTIFACT_DIR -name *.jar)"
result_file=$(find $ARTIFACT_DIR -name *.jar)
if [ -z "$result_file" ]; then
  echo "---> Build file could not be found"
  exit 1
fi
mv $result_file app.jar
```

###### 编写run
完成应用启动
```
#!/bin/bash -e
#
# S2I assemble script for the 'hello-make-s2i' image.
# The 'assemble' script builds your application source so that it is ready to run.
#
# For more information refer to the documentation:
#       https://github.com/openshift/source-to-image/blob/master/docs/builder_image.md
#

# If the 'hello-make-s2i' assemble script is executed with the '-h' flag, print the usage.
if [[ "$1" == "-h" ]]; then
        exec /usr/libexec/s2i/usage
fi

# Restore artifacts from the previous build (if they exist).
#
if [ "$(ls /tmp/artifacts/ 2>/dev/null)" ]; then
  echo "---> Restoring build artifacts..."
  shopt -s dotglob
  mv /tmp/artifacts/* ./
  shopt -u dotglob
[root@localhost makeS2i]# cat s2i/bin/run 
#!/bin/bash -e
#
# S2I run script for the 'hello-make-s2i' image.
# The run script executes the server that runs your application.
#
# For more information see the documentation:
#       https://github.com/openshift/source-to-image/blob/master/docs/builder_image.md
#
cd /tmp/src
ARTIFACT_DIR=${ARTIFACT_DIR:-target}
echo "---> Starting Java application"
echo "--> # APP_FILE = $APP_FILE"
echo "--> # JAVA_OPTS = $JAVA_OPTS"
APP_FILE="${APP_FILE:-app.jar}"
if [[ -f "$APP_FILE" ]]; then
  echo "---> APP_FILE found"
  echo "---> Running application from jar (java $JAVA_OPTS -jar $APP_FILE) ..."
  java $JAVA_OPTS -jar $APP_FILE
else
  echo "---> Running application from jar (java $JAVA_OPTS -jar $(find $ARTIFACT_DIR -name *.jar)) ..."
  java $JAVA_OPTS -jar `find $ARTIFACT_DIR -name *.jar`
fi
```

##### 生成构建器镜像
1. 回到顶层目录
![[Pasted image 20210804220524.png]]

2. 执行make build
执行的是Makefile，根据后面的参数进行不同操作。
这里是build，docker打包
```Makefile
IMAGE_NAME = hello-make-s2i

.PHONY: build
build:
        docker build -t $(IMAGE_NAME) .

.PHONY: test
test:
        docker build -t $(IMAGE_NAME)-candidate .
        IMAGE_NAME=$(IMAGE_NAME)-candidate test/run
```
镜像的tag名称，修改IMAGE_NAME定义

3. 查看打好的构建器镜像
![[Pasted image 20210804220923.png]]

##### 构建应用镜像
1. 切换到源代码目录
![[Pasted image 20210804221400.png]]

2. 执行构建
这里操作的是本地代码库，并将maven的repository挂载到主机目录，避免重复下载
`s2i build -v /home/dockerLearn/toolLearn/source_to_image/.m2:/root/.m2 . hello-make-s2i:latest s2i-java-hello-app`
build后面的参数，说明如下：
第一个参数：代码目录
第二个参数：构建器镜像的tag名称[[#生成构建器镜像]]
第三个参数：应用镜像的tag名称

3. 查看构建好的应用镜像
![[Pasted image 20210804222226.png]]

##### 启动应用
![[Pasted image 20210804222402.png]]

#### 编译的构建器镜像+多阶段构建镜像
(当前目录包含本次实践的所有资料)[[Docker/附件/source_to_image/makeS2i-multipile/README]]
**s2i的构建器镜像，只负责编译，不负责启动应用：避免将编译环境带到应用镜像中，减少包大小**

##### 前提
[[#准备MAVEN镜像]]
[[#创建构建器镜像模板]]
还需要准备JDK镜像
[frolvlad/alpine-java](https://hub.docker.com/r/frolvlad/alpine-java/tags?page=1&ordering=last_updated)
`docker pull frolvlad/alpine-java:jre8.202.08-slim`

##### 生成编译构建器镜像
我们只要编译，无须启动应用，所以run脚本不要写任何脚本

###### 开始编写构建规则
1. 编写Dockerfile
```Dockerfile
# hello-make-s2i
FROM maven:3.8.1-amazoncorretto-8

# TODO: Put the maintainer name in the image metadata
# LABEL maintainer="Your Name <your@email.com>"

# TODO: Rename the builder environment variable to inform users about application you provide them
# ENV BUILDER_VERSION 1.0
ENV MAVEN_BUILD_CMD="clean install" 

# TODO: Set labels used in OpenShift to describe the builder image
[root@localhost makeS2iBuildImage]# cat Dockerfile 
# hello-make-s2i
FROM maven:3.8.1-amazoncorretto-8

# TODO: Put the maintainer name in the image metadata
# LABEL maintainer="Your Name <your@email.com>"

# TODO: Rename the builder environment variable to inform users about application you provide them
# ENV BUILDER_VERSION 1.0
ENV MAVEN_BUILD_CMD="clean install -DskipTests" 

# TODO: Set labels used in OpenShift to describe the builder image
#LABEL io.k8s.description="Platform for building xyz" \
#      io.k8s.display-name="builder x.y.z" \
#      io.openshift.expose-services="8080:http" \
#      io.openshift.tags="builder,x.y.z,etc."
LABEL io.openshift.s2i.scripts-url="image://usr/libexec/s2i"

# TODO: Install required packages here:
# RUN yum install -y ... && yum clean all -y

# TODO (optional): Copy the builder files into /opt/app-root
# COPY ./<builder_folder>/ /opt/app-root/

# TODO: Copy the S2I scripts to /usr/libexec/s2i, since openshift/base-centos7 image
# sets io.openshift.s2i.scripts-url label that way, or update that label
COPY ./s2i/bin/ /usr/libexec/s2i

# TODO: Drop the root user and make the content of /opt/app-root owned by user 1001
#RUN chown -R 1001:1001 /opt/app-root

# This default user is created in the openshift/base-centos7 image
#USER 1001

# TODO: Set the default port for applications built using this image
# EXPOSE 8080

# TODO: Set the default CMD for the image
CMD ["/usr/libexec/s2i/usage"]
```

2. 编写assemble
```Dockerfile
#!/bin/bash -e
#
# S2I assemble script for the 'hello-make-s2i' image.
# The 'assemble' script builds your application source so that it is ready to run.
#
# For more information refer to the documentation:
#       https://github.com/openshift/source-to-image/blob/master/docs/builder_image.md
#

# If the 'hello-make-s2i' assemble script is executed with the '-h' flag, print the usage.
if [[ "$1" == "-h" ]]; then
        exec /usr/libexec/s2i/usage
fi

# Restore artifacts from the previous build (if they exist).
#
if [ "$(ls /tmp/artifacts/ 2>/dev/null)" ]; then
  echo "---> Restoring build artifacts..."
  shopt -s dotglob
  mv /tmp/artifacts/* ./
  shopt -u dotglob
fi

# TODO: Add build steps for your application, eg npm install, bundle install, pip install, etc.

# maven打包
cd /tmp/src/
echo "---> Building application from source..."
MAVEN_BUILD_CMD=${MAVEN_BUILD_CMD:-"install"}
echo "--> # MAVEN_BUILD_CMD = $MAVEN_ARGS"
if [ -f "mvnw" ]; then
  echo "---> Building application with maven wrapper..."
  ./mvnw $MAVEN_BUILD_CMD
else
  echo "---> Building application with installed maven..."
  mvn $MAVEN_BUILD_CMD -DskipTest
fi

# 在target目录找到打好的jar包，并改名为app.jar
ARTIFACT_DIR=${ARTIFACT_DIR:-target}
echo "--> # ARTIFACT_DIR = $ARTIFACT_DIR"
echo "---> Rename artifact $(find $ARTIFACT_DIR -name *.jar)"
result_file=$(find $ARTIFACT_DIR -name *.jar)
if [ -z "$result_file" ]; then
  echo "---> Build file could not be found"
  exit 1
fi
mv $result_file app.jar
```

3. 清空run脚本

###### 生成构建器镜像
```shell
cd makeS2iBuildImage/
make build
```

##### 使用构建器镜像，编译打包源代码
作为多阶段构建的第一个镜像
切换到源代码目录，执行
`s2i build -v /home/dockerLearn/toolLearn/source_to_image/.m2:/root/.m2 . s2i_multiple_build_image:latest s2i_multiple_build_image_app`

##### 使用多阶段构建完成启动应用
docker的技术[[#Multiple From Build]]
利用[[#使用构建器镜像，编译打包源代码]]生成的镜像，将镜像中的编译好的包拷贝到应用镜像

1. 编写Dockerfile
```Dockerfile
FROM frolvlad/alpine-java:jre8.202.08-slim
COPY --from=s2i_multiple_build_image_app ./app.jar .
CMD ["java","-jar","app.jar"]
```
`docker build -t s2i_multiple_build_java_hello .`

2. 启动容器看看
![[Pasted image 20210805173355.png]]

## 探究原理
[参考介绍的原理，但有些步骤没说清楚](http://xcodest.me/s2i.html)
![[Pasted image 20210806174112.png]]

[参考s2i官方的原理讲解，也是不讲清楚](https://github.com/openshift/source-to-image/#build-workflow)

**下面自己探索出原理**
(当前目录包含本次实践的所有资料)[[Docker/附件/source_to_image/s2iTheory/README]]

1. 创建构建器镜像
以编译+启动一体式的镜像为基准[[#生成构建器镜像]]
![[Pasted image 20210806215723.png]]
 ^853985

2. 创建编译容器
`docker create --name s2i-theory-build-images s2i-theory-build-images:latest "/bin/sh" "-c" '/usr/libexec/s2i/assemble'`
以[[#^853985]]创建的镜像，创建编译容器，并且CMD设为编译脚本：/usr/libexec/s2i/assemble
 ^dbd0bc
 
3. 创建/tmp/src目录
因为s2i构建器镜像，操作的目录是/tmp/src，所以要确保存在该目录。
通过inspect镜像信息，GraphDriver.Data.UpperDir得知当前容器层的存放目录。
容器id就是[[#^dbd0bc]]
```
mkdir -p `docker inspect -f '{{.GraphDriver.Data.UpperDir}}' 5c12db05b18e`/tmp/src
```
* 检查是否创建成功
```
tree `docker inspect -f '{{.GraphDriver.Data.UpperDir}}' 5c12db05b18e`
```
![[Pasted image 20210806221832.png]]

4. 拷贝源代码到该容器
切换到源代码目录：app/S2iJavaHelloApp/，执行：
`tar -cf - . | docker cp - 5c12db05b18e:/tmp/src`
容器id就是[[#^dbd0bc]]

* **s2i的源代码存放目录是在/tmp/src，所以我们要复制到该目录**

* **这里采用“-”，是为了优雅复制文件到容器内部**
不会在主机留下任何痕迹，所以将压缩内容放入到输入流(stdin)，然后docker的输出流(stdout)接收

* 查看是否拷贝成功
```
tree `docker inspect -f '{{.GraphDriver.Data.UpperDir}}' 5c12db05b18e`
```
![[Pasted image 20210806223248.png]]

5. 启动编译容器
`docker start 5c12db05b18e`

4. 等待编译完毕
`docker logs -f 5c12db05b18e`
![[Pasted image 20210806223727.png]]
**跑完后，容器就退出了**

6. 该容器反向生成应用镜像
使用docker commit(命令归总)[[Docker重点]][[2021-08(31)]]
`docker commit -c 'CMD ["/usr/libexec/s2i/run"]' 5c12db05b18e s2i-theory-app`
记得要改启动命令，之前是编译脚本assemble，现在改成run脚本
![[Pasted image 20210806225356.png]]

7. 启动应用镜像
`docker run s2i-theory-app`
![[Pasted image 20210806225556.png]]

8. 收尾工作
* **清除编译容器[[#^dbd0bc]]**
![[Pasted image 20210806225959.png]]
`docker rm s2i-theory-build-images`

 ### 原理总结
 * **大功臣1：docker cp与tar标准输入输出流的联动**，完成源代码拷贝进容器
 * **大功臣2：docker commit，将编译容器，反转成镜像，并且扭转启动命令，由编译脚本改成启动脚本**
 * 基于上面两点，一个构建器镜像就可以完成编译、启动

## 注意
### maven要将本地repository挂载到容器，减少构建器镜像重复下包
s2i build 支持挂载
`s2i build -v /path/to/repository:/root/.m2/repository . xxxBuildImages xxxAppTagName
`
/root/.m2/repository是进入构建器镜像得知：`find . -name maven`

### 修改构建器镜像中maven的setting.xml，资源库地址改成国内

### 要将编译和运行分成两个镜像，不要将编译环境带到应用镜像中，减少包大小
利用Docker提供的多阶段构建，Dockerfile可拥有多个FROM，然后后面FROM的操作可以使用前面FROM的产物


#### Multiple From Build
（待合并到Docker官方文档）[[2021-08(31)]]

[Docker FROM官方文档](https://docs.docker.com/engine/reference/builder/#from)

##### 用法描述
* 因为每次执行FROM，除了ARG，任何痕迹都会清除。因此一般用于拷贝文件
* 支持两种方式多阶段构建
	1. 同一个Dockerfile引用前面的FROM[[#^3169f7]]
	2. 不同Dockerfile之间引用[[#^d5538c]][[#^8a3f02]]
* 通过COPY --from=\<xxxImage\> xxx xxx拷贝文件
	xxxImage可以是：`镜像id`，`name`，`镜像tag`
	**name**：在FROM起个别名：`FROM xxxImage AS xxxName`	
	
##### 实操
###### 三种使用方式
1. 引用name ^3169f7
* 构建镜像
```Dockerfile
FROM busybox AS image1
COPY a.txt .
RUN mv a.txt b.txt

FROM busybox
COPY --from=image1 b.txt .
```

`docker build -t multiple-stage-from1 -f Dockerfile .`
![[Pasted image 20210805112349.png]]

* 运行容器看看
`docker run -it --rm multiple_stage_from1 /bin/sh`
![[Pasted image 20210805113837.png]]

2. 引用镜像tag
第二个镜像引用第一个镜像 ^d5538c
* 先构建第一个镜像 ^c56b60
```Dockerfile
FROM busybox
COPY a.txt .
RUN mv a.txt b.txt
```
`docker build -t multiple_stage_from_image1 -f Dockerfile_Image1 .`
![[Pasted image 20210805114502.png]]

* 构建第二个镜像
```Dockerfile
FROM busybox
COPY --from=multiple_stage_from_image1:latest b.txt . 
```
`docker build -t multiple_stage_from2 -f Dockerfile2 .`
![[Pasted image 20210805113519.png]]

* 运行容器看看
`docker run -it --rm multiple_stage_from2 /bin/sh`
![[Pasted image 20210805113718.png]]

3. 引用镜像id
**这种方式需要知道镜像id，所以不适用在同个Dockerfile多阶段构建** ^8a3f02
* 用的第二种方式创建的第一个镜像[[#^c56b60]]
```Dockerfile
FROM busybox
COPY --from=dadb8df50166 b.txt .
```

`docker build -t multiple_stage_from3 -f Dockerfile3 .`
![[Pasted image 20210805114651.png]]

* 运行容器看看
`docker run -it --rm multiple_stage_from3 /bin/sh`
![[Pasted image 20210805114739.png]]

###### 扩展
1. 三个阶段构建
```Dockerfile
FROM busybox AS image1
COPY a.txt .
RUN mv a.txt b.txt

FROM busybox AS image2
COPY a.txt .
RUN mv a.txt c.txt

FROM busybox
COPY --from=image1 b.txt .
```
`docker build -t multiple_stage_from_more -f Dockerfile_More_Image .`
![[Pasted image 20210805115238.png]]

2. 运行容器看看
`docker run -it --rm multiple_stage_from_more /bin/sh`
![[Pasted image 20210805115318.png]]

###### 收尾清理
* **如果多阶段构建过程，中间镜像只被使用一次，所以要清理掉**
```
docker rmi `docker images -f "dangling=true"`
```
87