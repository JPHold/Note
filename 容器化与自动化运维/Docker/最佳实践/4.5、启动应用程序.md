[TOC]

# 三种命令启动
## CMD(容器执行)
* Dockerfile多个CMD，以最后一个为准
* 如果启动容器时指定启动命令，也会覆盖Dockerfile的CMD命令
	`docker run xxxImage xxxCommand`，xxxCommand会覆盖
	
* 存在[[#ENTRYPOINT]]，则会将CMD的参数当做ENTRYPOINT的参数
```
FROM redis
CMD ["/usr"]
ENTRYPOINT ["/bin/ls"]
```
启动后：`docker run --rm  sum_cmd_entrypoint`
![[Pasted image 20210728154452.png]]

* 在docker run最后面的字符串，这时不是命令，而是当做ENTRYPOINT的参数
![[Pasted image 20210728155207.png]]
![[Pasted image 20210728155247.png]]

## ENTRYPOINT(容器执行)
* docker run --entrypoint=""替换掉Dockerfile的ENTRYPOINT命令

## RUN(镜像执行)

# 启动方式

## 调用二进制文件
比如redis，使用`CMD ./redis-server`

## 调用脚本
跟[[#调用二进制文件]]相似
同样以redis为例，将./redis-server写进脚本，然后调用脚本即可
**需要两步**
1. 将脚本复制到容器内部
	`ADD xxx.sh /xxxDir/xxx.sh`
2. 调用
	`CMD ["/xxxDir/xxx.sh"]`
	
## 显示使用文档
**不启动任何应用程序，只是打印出使用说明**
这篇文章使用了(待整理)[s2i](https://github.com/openshift/source-to-image)[[2021-08(31)]][[高效]]（镜像构建器，直接从源代码到镜像的快速打包，无需写Dockerfile）

## systemd作为服务启动
需要安装systemd：apt-install systemd
**需要两步**
1. `RUN systemctl enable rsyslog` 通知systemd启用该服务
2. `RUN /usr/sbin/init` 交给init进程处理剩余工具

## 