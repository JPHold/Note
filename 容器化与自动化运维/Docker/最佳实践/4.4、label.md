[TOC]

# atomic制定的通用标签
[ContainerApplicationGenericLabels](https://github.com/projectatomic/ContainerApplicationGenericLabels)

# Docker object labels(待整理到Docker的生产环境使用文档，只完成一部分65)[[2021-07(30)]]
[Docker object labels](https://docs.docker.com/config/labels-custom-metadata/)

## 可支持的对象
1. Images镜像
2. Containers容器
3. Local daemons守护进程
4. Volumes卷
5. Network网络
6. Swarm nodes节点
7. Swarm service服务

## 意义何在
1. 标记哪些镜像为一组，类似组织架构
2. 记录授权信息等有价值的信息
3. 补充信息，比如标记容器、卷、网络三者的关系
4. 写下对应用程序或业务有帮助的信息

## 格式和规范
* \<key\>:\<value\>键值对
* 	key名称可以是字母、数字、字符串、.、-
* 	value值可以是任何数据的字符串类型，包括：JSON、XML、CSV、YAML

###  key的编写规范
**并没有强制执行**

1. **以域名的反向DNS表示法为开头**
域名为example.com，那么就是com.example
key就是com.example.some-label

2. **确保域名所有者许可，才能使用**

3. **不要使用内部关键字**
`Docker.*`、`io.Docker.*`、`org.dockerproject.*`

4. key名称规范
* 以小写字母作为开头和结束
* 不能出现连续.和-

### value的编写规范
1. **必须将数据都转化为字符串**
比如json，那就要JSON.stringify()

2. **Docker不支持反序列化，所以不能将JSON或XML视为嵌套结构**
比如key为key1，value为{"a": {"a1":"1"}}，过滤docker images --filter时，不能这么写："label=key1=a.a1"

## 实操标签
**每种对象[[#可支持的对象]]，使用方式都不一样**

* 只有`swarm node`和`swarm service`的标签才会动态更新，其他的都是静态，意味着要重新构建

### 过滤功能
`docker images --filter "xxx"`、`docker images -f "xxx"`
**还支持or**
`docker images --filter "xxx" -f "xxx"`

#### Images
支持五种方式

##### 查找空tag镜像
###### 空tag镜像的产生原因
多次对同一个Dockerfile构建，tag也相同，但Dockerfile内容有一点不同，每次构建都会将之前相同tag的镜像，其REPOSITORY值改成：\<none\>[[Docker重点]]

```Dockerfile
FROM redis
LABEL version="1.0"  \
  com.budd.label.author="budd"
```
![[Pasted image 20210729151442.png]]

```Dockerfile
FROM redis
LABEL version="1.0"  \
  com.budd.label.author="budd2"
```
![[Pasted image 20210729151505.png]]

###### 适用场景
删除这些没用的镜像
docker rmi \`docker images -f "dangling=true" -q\`

##### 查找某个标签或某个标签值
label=\<key\>和label=\<key\>=\<value\>

`docker images -f "label=com.budd.label.author"`
`docker images -f "label=com.budd.label.author=budd"`
![[Pasted image 20210729161841.png]]

##### 查找在某个镜像之前的镜像
![[Pasted image 20210729165117.png]]
`docker images -f "before=primetoninc/jdk"`

##### 查找在某个镜像之后的镜像
![[Pasted image 20210729165117.png]]
`docker images -f "since=export_mysql"`

##### 正则匹配
跟`docker images | grep xxxPatern`相似
`docker images -f "reference=xxxPatern"`
* 查找TAG为latest的镜像
`docker images -f "reference=\*:latest*"`
![[Pasted image 20210729170017.png]]

* 查找REPOSITORY以arg开头的镜像
`docker images -f "reference=arg*"`
![[Pasted image 20210729170106.png]]

#### Containers
以这个容器清单为测试数据
![[Pasted image 20210729172111.png]]
![[Pasted image 20210801115544.png]]
| 过滤标识 | 说明 | 例子 |
| ------- | --------| --------|
| id | 容器id过滤 | `docker ps -a -f "id=70769fd1f5af"` |
| name | 容器名称过滤 | `docker ps -a -f "name=recursing_edison"` |
| label | 镜像设置的标签或容器覆盖设置的标签过滤 | `docker ps -a -f "label=version"`、`docker ps -a -f "label=version=1.0"` |
| exited | 因描述的是退出状态，所以必须搭配--all(-a)一起使用。value为数字(如1、130等) | `docker ps -a -f "exited=1"` |
| status | 容器运行状态过滤：created、restarting、running、removing、paused、exited、dead(容器的运行状态集)[[2021-07(30)]] | `docker ps -a -f "status=running"`、`docker ps -a -f "status=exited"` |
| ancestor | 容器采用的镜像过滤(支持祖父级别镜像过滤：容器1采用镜像1，镜像1又采用基础镜像2，那么支持使用镜像2作为过滤条件) | `docker ps -a -f "ancestor=redis"` ![[Pasted image 20210729174443.png]] |
| before、since | 以某个镜像名称为条件，按时间过滤在他之前、之后的容器 | `docker ps -a -f "since=brave_jones" -f "before=tender_cerf"`。并不是像文档描述那样支持容器id查询条件：![[Pasted image 20210729175419.png]] |
| volume | 挂载目录过滤(主机目录和容器目录都支持过滤) | ![[Pasted image 20210729181007.png]]，`docker ps -a -f volume=/home1`、`docker ps -a -f volume=/home`|
| network | 使用网络过滤(官方文档说也支持网络id过滤，试了并不行[[2021-07(30)]]) | 未指定网络，默认为bridge：`docker ps -a -f network=bridge` |
| publish | 过滤发布到主机的端口或端口/协议(tcp、udp)，端口支持范围查找 | (官方的例子还是错的。。。)[[Docker重点]][[#^396cbc]]，所以就不用官方的例子了。`docker ps -f publish=23331`![[Pasted image 20210801122608.png]] `docker ps -f publish=23331-23332`、 `docker ps -f publish=23331/tcp`|
| expose | 过滤发布到容器内部的端口或端口/协议(tcp、udp)，端口支持范围查 |`docker ps -f expose=6379` ![[Pasted image 20210801122723.png]]  `docker ps -f expose=6379-6380`、 `docker ps -f expose=6379/tcp`|
| health | 健康状态过滤（Dockerfile必须配置HEALTHCHECK才会有，没配置则为`none`）（这是结果导向）(支持：`starting`, `healthy`, `unhealthy` ， `none`) | `docker ps -f health=none`查找没配置健康状态的容器![[Pasted image 20210801222233.png]] |
| is-task | 是否任务服务过滤（估计是systemd自启动服务）[[2021-07(30)]] | `docker ps -f is-task=false` |

##### 错误的地方
* publish的例子是错的
![[Pasted image 20210801121732.png]]
官方使用`docker ps --filter publish=80`过滤，结果显示是第二个容器 ^396cbc

而我自己试验，并没有容器可以匹配
![[Pasted image 20210801121947.png]]
`docker ps --filter publish=80`
![[Pasted image 20210801122152.png]]

应该使用expose
`docker ps --filter expose=80`
![[Pasted image 20210801122213.png]]