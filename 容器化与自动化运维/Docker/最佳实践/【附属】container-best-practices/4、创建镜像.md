[TOC]

# 创建镜像
## 创建基本镜像
### 选择基础镜像
有两种选择

#### 直接使用Linux发行版
也就是我们用虚拟机安装的系统iso，**但大小实在太大了，并不适合**，推荐使用[[4、创建镜像#最小操作系统和一组基本操作的工具，组成的基础镜像]]

#### 最小操作系统和一组基本操作的工具，组成的基础镜像
大小就没有[[4、创建镜像#直接使用Linux发行版]]那么庞大，轻量级的，也就几百兆。
像`Fedora`、`Centos`

#### 重新构建
一般是修复安全漏洞，才需要更新基础镜像，反正就确定他们的更新策略

### 创建基础镜像
Docker文档推荐两种方式( [Docker 文档](https://docs.docker.com/engine/userguide/eng-image/baseimages/))：tar和FROM

#### tar自己打包并导入
需要在github下载linux发行版的源代码
`tar -C  <压缩包的保存目录>  -c . | docker import - <基础镜像名称>`
* 将当前目录下的源代码压缩，因为没有`-f`参数指定，因此不会保存，**猜测是保存到内存[[2021-07(30)]]**
* 压缩的数据传入到docker import去执行
![[Pasted image 20210726160807.png]]


#### 使用scratch存储库
* 不能被pull、run
* 只是个保留名称，可以使用它创建空壳镜像(最小镜像，大小为0B)
* 能够执行可执行文件
* docker有例子https://docs.docker.com/engine/userguide/eng-image/baseimages/，**但执行失败**[[2021-07(30)]]
![[Pasted image 20210726173941.png]]

##### 创建0B大小的空壳基础镜像
`tar cv --files-from /dev/null | docker import - scratch1`

##### 创建执行文件的基础镜像
```
FROM scratch
COPY hello /
CMD ["/hello"]
```


## 创建系统镜像
应该是Docker daemon启动之前，启动容器服务(待验证)[[2021-07(30)]]

https://github.com/projectatomic/atomic-system-containers(待学习)[[2021-07(30)]]

## 做到小而简洁的镜像
### 合并命令
因为每一个命令，都会创建一个镜像层，命令过多时，镜像的大小就会很大，因此需要按类型将这些命令进行合并。

#### &&
前面一个命令执行成功，才执行下一个(这是shell的知识)
使用&&分隔每个命令（**方便阅读**）、使用\\换行

之前的Dockerfile编写是这样的：
```
RUN dnf install -y --setopt=tsflags=nodocs httpd vim
RUN systemctl enable httpd
RUN dnf clean all
```
优化后是这样的：
```
RUN true \
    && dnf install -y --setopt=tsflags=nodocs \
        httpd vim \
    && systemctl enable httpd \
    && dnf clean all \
    && true
```

上述编写的好处：
1. &&标记一条命令的开始和结束，方便阅读
2. true避免了修改命令，会修改错的问题，如果要删除命令，还会丢失修改历史
3. true

**还能继续优化**
* 根据命令的类型分层一组，然后这些组分层RUN
比如这样的场景：安装某个安装包有如下步骤
1. 安装依赖项 ^36b2f2
2. 克隆源代码 ^53c175
3. 配置 ^f409fd
4. 编译 ^bb5374

第一步[[#^36b2f2]]、第二步[[#^53c175]]列为一组
第三步[[#^f409fd]]、第四步[[#^bb5374]]列为一组
所以最终的Dockerfile这么写：
```
RUN true \
	&& 安装依赖项 \
	&& 克隆源代码
	&& true
RUN true \
	&& 配置 \
	&& 编译 \
	&& true
```

#### ;
每个命令的执行结果，不影响下一个命令的执行
```
RUN dnf install -y --setopt=tsflags=nodocs \
        httpd vim \
    ; systemctl enable httpd \
    ; dnf clean all
```

### 清除包缓存和下载的临时包
以yum为例，yum install会将下载的软件包和header存储在缓存目录中
我的缓存目录是在`/var/cache/yum/x86_64/7`
所以需要执行yum clean all（all包含：headers, packages, metadata, dbcache, plugins, expire-cache, rpmdb）

**安装完毕，需要执行清除，镜像大小就变小很多**

#### 列举不同包管理器如何清除
需要注意rvm，会依赖其他包管理器，所以还需要`yum clean all`
| 包管理器 | 清除命令 |
| ------- | --------|
| yum | yum clean all |
| dnf | dnf clean all |
| rvm | rvm cleanun all |
| gem | gem cleanup |
| cpan | rm -rf ~/.cpan/{build,sources}/* |
| pip | rm -rf ~/.cache/pip/* |
| apt-get | apt-get clean |
 
 #### 镜像层是否挤压合并，对清除的影响
 * 如果最终会挤压合并，那么不用每条命令都执行清除，写成如下即可
```
FROM fedora
RUN dnf install -y mariadb
RUN dnf install -y wordpress
RUN dnf clean all
```
如果没有挤压合并，那么就需要这么写：
```
FROM fedora
RUN dnf install -y mariadb wordpress && dnf clean all
```

这两个Dockerfile构建出来的镜像，大小就会差很多
![[Pasted image 20210727102259.png]]

### 删除用完或未使用的包
**删除包需要谨慎，特别是你觉得没用的，万一是其他包的依赖包呢**
所以只能一点点删除，并测试应用程序是否能启动

**剩下的就交给包管理器处理，自动清理未使用的包(待验证)[[2021-07(30)]]**
像dnf，是`dnf autoremove`
像yum，是`yum autoremove`

### 删除文档或保留文档
下载软件包，会将文档也一并下载，我们一般不需要，所以也删除吧

#### 删除文档
`yum -y install docker --setopt=tsflags=nodocs`

#### 保留文档
##### 保留单个软件包的文档
`yum -y install docker --setopt=tsflags=''`

##### 保留所有软件包的文档
`yum -y reinstall "*" --setopt=tsflags=''`

#### 全局保留
修改/etc/yum.conf
如果存在`tsflags=nodocs`则删除该配置
`RUN [ -e /etc/yum.conf ] && sed -i '/tsflags=nodocs/d' /etc/yum.conf || true`
**d：是删除的意思**
(待学习，菜鸟教程就行，基本使用sed)[[2021-07(30)]]

### 挤压合并层
带来的好处：
1. 性能
因为镜像层是写时复制文件系统，在运行容器时，才会将数据拷贝到容器层。所以层数越多，搜索数据在哪个镜像层的时间就越久，构建最终容器自然就越久。

**挤压就减少了层数，减少搜索深度**

2. 镜像大小
通常镜像由其他镜像组合起来，镜像大小也是由他们堆起来的，所以挤压就可以防止不需要的尺寸增加（待验证）[[2021-07(30)]]

3. 组织
控制镜像的结构，按逻辑去合并镜像层，减少了层数

#### 如何操作
##### 使用Docker1.13推出的--squash
启用压缩功能(待学习)[[2021-07(30)]] 

##### 使用docker save保存以及load加载
文章说会压缩成一个镜像层，这会有点困惑：docker save会保留缓存历史日志。
看下面的截图，我们来分析一下
* docker load我们save下来的镜像
`docker save nexus:15001/lv5b-cdr-p > save_cdr-p.tar`
`docker load -i save_cdr-p.tar`
 ^9fd469
 
* 在项目下，重新构建
![[Pasted image 20210727152558.png]]
 ^0d9c17
 
* 再次构建
![[Pasted image 20210727152703.png]]
 ^4a713f
 
* 查看load镜像[[#^9fd469]]的缓存历史日志
![[Pasted image 20210727152726.png]]
 ^48271e
* 我们两次构建后的镜像[[#^0d9c17]][[#^4a713f]]，查看其缓存历史日志
![[Pasted image 20210727152747.png]] ^658a4c

1. 通过第一次构建[[#^0d9c17]结果来看，并没有踩中缓存，**可以说明load镜像虽然有缓存历史日志，但IMAGE这栏是<missing>，因此并不能利用缓存[[#^48271e]]**
2. 结合[[#^4a713f]]、[[#^658a4c]]，总共5个步骤，该镜像的缓存历史日志也有对应5个IMAGE层。**所以可以说明只有IMAGE有值的层，才能缓存并被使用（待核查）[[2021-07(30)]]**
	
-----
我们看下使用docker export+docker import方式有何不同
* 只能导出容器
`docker export 3ea244c4ba1c -o export_cdr-p.tar`

* 导入，是保存到镜像而不是容器
`docker import export_cdr-p.tar nexus:15001/lv5b-cdr-p_export`
	
* 查看缓存历史
![[Pasted image 20210727155850.png]]

1. 真正的压缩成一个镜像层。没有缓存历史日志
2. **不能启动，会报错，所以只能适用于基础镜像，而不适用于应用容器**
![[Pasted image 20210728161735.png]]	

挤压的目的，是为了减少镜像大小，但我们在前面的操作，选用的是应用程序，导致大小差别不大
![[Pasted image 20210727163713.png]]
打的tar包
![[Pasted image 20210727163805.png]]

**我们换个其他镜像，这次选用mysql数据库**
![[Pasted image 20210728144646.png]]

	
##### 使用第三方工具
比如Marek Goldmann 的[docker-squash](https://github.com/goldmann/docker-squash)
(待学习)[[2021-07(30)]]

