	[TOC]

# 特性
| 特性                                                                                                                                                                                                   | 描述                                                                                                                                                                        | 注意                                                                                                                                     |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| 大括号语法（Mustache胡须）：{{ xxx }}                                                                                                                                                                  | 响应式变量；支持简单表达式，比如字符串拼接、加减乘除等                                                                                                                      |                                                                                                                                          |
| 一般创建Vue对象，取名都是vm（ViewModel的意思，视图模型）                                                                                                                                               |                                                                                                                                                                             |                                                                                                                                          |
| [`<template>` 元素](https://cn.vuejs.org/v2/guide/conditional.html#%E5%9C%A8-lt-template-gt-%E5%85%83%E7%B4%A0%E4%B8%8A%E4%BD%BF%E7%94%A8-v-if-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%88%86%E7%BB%84) | 不可见的包裹元素，并不会渲染出来，常与条件渲染配合使用                                                                                                                      |                                                                                                                                          |
| [v-if并不是销毁所有元素并重建，而是适当性地复用元素](https://cn.vuejs.org/v2/guide/conditional.html#%E7%94%A8-key-%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%85%83%E7%B4%A0)            | 指定key可以停止复用                                                                                                                                                         |                                                                                                                                          |
| [v-if和v-show的差别](https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show)                                                                                                                    | v-show一开始就渲染出来，只是为false时则隐藏起来；v-if是需要时才渲染                                                                                                         |                                                                                                                                          |
| [v-if和v-show不要同时用在同个元素上](https://cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7%E5%BF%85%E8%A6%81)                              |                                                                                                                                                                             |                                                                                                                                          |
| v-for的**就地复用问题**                                                                                                                                                                                | 数据顺序的变化，并不会对应地移动DOM元素，而是直接复用（vue3和vue2都会），最好用:key指定[[#input这类有状态的元素，如果没采用vue指令，会出现错位]]                            |                                                                                                                                          |
| [[#事件绑定]]：[原文](https://cn.vuejs.org/v2/guide/events.html)                                                                                                                                       | 指令是on:xxx事件。支持直接在指令写js、调用函数；支持[修饰符，对事件类型的分类处理](https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6) | 1. 不推荐直接在指令写js，因为业务逻辑一般都是复杂的  2. 调用函数分为绑定方法和内联JavaScript调用方法（只是前者没带参数和方法体、后者有） |
| [[#表单输入绑定（双向绑定）]]：[原文](https://cn.vuejs.org/v2/guide/forms.html)                                                                                                                        | 所有用到这个变量，都会同时响应。支持text、textarea、radio、checkbox等                                                                                                       |                                                                                                                                          |
| [[#组件基础]]                                                                                                                                                                                                       | **1.** template模板如果有多个元素，记得使用div包裹，不然只会显示第一个元素 **2.** template模板内容，支持插槽：<slot>; 在html-text内容，可以加入你自定义的html内容。模板基础上，加上一些独有内容，适应变化 **3.** emit，与外部进行通信，通过函数	组件在html，声明@xxxEmitFunction="外部方法名"



# 指令种类
加强型辅助
分别三种：

## 指令本身
控制当前的元素
```html
判断指令：<p v-if="isTrue">判断为true</p>

var vm = new Vue({
				el: "#app",
				data: {
					isTrue: true
				}
			});
```

## 指定参数
比如v-bind:xxx，xxx为参数
动态绑定
```html
指令参数：<a v-bind:href="url">跳转url</a>

var vm = new Vue({
				el: "#app",
				data: {
					url: "http://www.baidu.com"
				}
			});
```

## 指定修饰符
对指令的进一步限制范围
比如限定点击事件的传递范围
```html
指令修饰符：
			<div @click="click1">
				<div @click="click2">
					click me(冒泡传递点击事件)
				</div>
			</div>
			<div @click="click1">
				<div @click.stop="click2">
					click me(阻止冒泡传递点击事件)
				</div>
			</div>

var vm = new Vue({
				el: "#app",
				methods:{
					click1 : function(){
						console.log('click1......');
					},
					click2 : function(){
						console.log('click2......');
					}
				}
			});

```

# 指令清单

* **简写**

>@是v-on的简写
>:是v-bind的简写

| 指令                                          | 简写 | 描述                                                         |
| --------------------------------------------- | ---- | ------------------------------------------------------------ |
| [v-bind](https://cn.vuejs.org/v2/api/#v-bind) | :    | 动态绑定多个属性（这些属性是html标签本身的属性）             |
| [v-on](https://cn.vuejs.org/v2/api/#v-on)     | @    | 为当前标签绑定事件，并可以进一步限制修饰（比如阻止点击冒泡） |

# 样式绑定

## class方式

使用v-bind指令
分别静态绑定和动态绑定

1. 静态绑定

使用单引号：'' 包裹class名称
```html
<div class="c1" v-bind:class="['c2','c3']">用单引号包裹</div>

var app = new Vue({
			el: '#app'
		});

<style>
		.c1 {
			width: 200px;
			height: 200px;
			text-align: center;
			line-height: 200px;
		}
		.c2{
			background-color: red;
		}
		.c3{
			font-size: 30px;
			color: green;
		}
	</style>
```

2. 动态绑定

有三种写法
其中内联样式，跟以前html内联样式一样，只是将值改成响应式变量

```html
		  <p>动态绑定</p>
		  <div class="c1" v-bind:class="{c2: isRed,c3: isGreen}">动态控制样式</div>

		 <p></p>
		 <div class="c1" v-bind:class="[isRed?'c2':'',isGreen?'c3':'']">支持三元运算</div>
		
		 <p>内联样式</p>
		 <div :style="{color:color,background:isRed?'red':'',fontSize:size}">style动态变化</div>

<script>
		var app = new Vue({
			el: '#app',
			data: {
				isRed: true,
				isGreen: false,
				color: 'green',
				size: '30px'
			}
		});
	</script>
	<style>
		.c1 {
			width: 200px;
			height: 200px;
			text-align: center;
			line-height: 200px;
		}
		.c2{
			background-color: red;
		}
		.c3{
			font-size: 30px;
			color: green;
		}
	</style>

```

## 内联方式
> 不通过class方式，是直接在html写样式配置
```html
<div :style="{color:color,background:isRed?'red':'',fontSize:size}">style动态变化</div>
```
**而且属性名跟class方式，是不一样的**

# 条件渲染
| 指令   | 描述                                                                                              | 场景 |
| ------ | ------------------------------------------------------------------------------------------------- | ---- |
| [v-if](https://cn.vuejs.org/v2/guide/conditional.html#v-if)   | 控制是否渲染出来，配合v-else-if、v-else使用，但有点奇怪，后面两个命令不是在v-if命令内部，而是同级 | 是真正的条件渲染，会销毁或重建子组件和事件监听；**不适合频繁切换**     |
| [v-show](https://cn.vuejs.org/v2/guide/conditional.html#v-show) | 控制是否展示出来，通过修改内联样式：display属性，为false则不展示                                  | 一开始就渲染出来，只是赋予display属性，隐藏或展示，只需修改该属性，不会重建；**适合频繁切换**     |

## v-if
```html
	<body>
		<div id="app">
			<p v-if="type === 'A'">A</p>
			<p v-else-if="type === 'B'">B</p>
			<p v-else-if="type === 'C'">C</p>
			<p v-else>not A/B/C</p>
		</div>
	</body>
	<script>
		var vm = new Vue({
		  el: '#app',
		  data: {
		    type: 'A'
		  }
		});
	</script>
```
![[Pasted image 20220716111944.png]]

## v-show
```html
<body>
		<div id="app">
			<p id="showId" v-show="isShow">是否展示：{{ isShow }}</p>
			<p>他的内联样式：{{ showStyle }}</p>
		</div>
	</body>
	<script>
		var vm = new Vue({
		  el: '#app',
		  data: {
			isShow: false,
			showStyle: null
		  }
		});
		
		vm.showStyle = document.getElementById('showId').getAttribute('style');
	</script>
```

![[Pasted image 20220716112146.png]]

# 列表循环
支持数组和对象
## v-for对象
```html
<li v-for="(item,key) in object">
	{{ key }} ：{{ item }}
</li>
```

```js
data: {
	object: {
		'key3': "value5",
		"key4": "value6"
	}
},
```

## v-for数组
```html
<li v-for="(item,index) in list">
	{{ index }} = {{ item.key1 }}
</li>
```

```js
data: {
	list: [{
			'key1': "value1"
		},
		{
			'key1': "value2"
		},
		{
			'key1': "value3"
		}
	]
},
```

## 注意

### 就地复用（不移动DOM元素，只更新状态），导致元素错位
官方原话如下：
> 当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。
> 
> 如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 track-by="$index"。
> 
> 这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。

提到就地更新、如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素。

**举个例子：**
> 以数组:[1,2,3]，分别对应input值：value1、value2、value3为例，删除2位置的数据，变成[1,3]
> 
> 跟原来的数组[1,2,3]一一对比
-- 1和1没变化，不更新第一个input元素的值
-- 2和3不同，第二个input元素的值应该更新为value3
-- 3和undefined不同，删掉3，删除第三个input元素

### input这类有状态的元素，如果没采用vue指令，会出现错位
* input未采用:value指令，来填充值（也就是手动输入），删除数组中某个位置的数据（一切调整数组顺序的行为），会导致该元素与数据不一致
* **产生这个问题的原因：就地复用（不移动DOM元素，只更新状态），导致元素错位**

官方原话如下（非常难懂）：
> 当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。
> 
> 如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 track-by="$index"。
> 
> 这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。

提到就地更新、如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素。

**举个例子：**
> 以数组:[1,2,3]，分别对应input值：value1、value2、value3为例，删除2位置的数据，变成[1,3]
> 
> 跟原来的数组[1,2,3]一一对比
-- 1和1没变化，不更新第一个input元素的值
-- 2和3不同，第二个input元素的值应该更新为value3，**但因为input元素没加vue控制，因此不动，为vlaue2**
-- 3和undefined不同，删掉3，删除第三个input元素
[讲解](https://www.zhihu.com/question/61064119)

执行这两步后，发现3对应的input值是value2，本应该是value3才对（下面第二个效果）
![[20220807110700.gif]]

**代码**
```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script src="../vue.js"></script>
	</head>
	<body>
		<div id="app">
			<ul>
				<p>取消就地复用+input无数据绑定，元素始终与数据一致</p>
				<li v-for="(item,index) in list" :key="item.key1">
					{{ index }} = {{ item.key1 }}
					<input type="text"></input>
					<button @click="onDelete(index)">delete</button>

				</li>
				<p>就地复用+input无数据绑定，导致元素与数据不一致（错位展示）</p>
				<li v-for="(item,index) in list" >
					{{ index }} = {{ item.key1 }}
					<input type="text"></input>
					<button @click="onDelete(index)">delete</button>
				
				</li>
				
				<p>就地复用+input数据绑定，元素始终与数据一致</p>
				<li v-for="(item,index) in list" >
					{{ index }} = {{ item.key1 }}
					<input type="text" :value="item.key1"></input>
					<button @click="onDelete(index)">delete</button>
				
				</li>
			</ul>
			<ul>
				<li v-for="(item,key) in object">
					{{ key }} ：{{ item }}
				</li>
			</ul>
		</div>
	</body>
	<script>
		var vm = new Vue({
			el: '#app',
			data: {
				list: [{
						'key1': "value1"
					},
					{
						'key1': "value2"
					},
					{
						'key1': "value3"
					}
				],
				object: {
					'key3': "value5",
					"key4": "value6"
				}
			},
			methods:{
				onDelete: function(index){
					vm.list.splice(index, 1);
				}
			}
		});
		
	</script>
</html>

```

^8b0664

#### 正确使用
[[#input这类有状态的元素，如果没采用vue指令，会出现错位]]中第1、3个例子
方法如下：
1. 没有数据绑定的状态组件，那么就需要加上`:key="xxxKey"`，而且不能是index，index跟没加`:key`是同等效果。必须是采用数组中的值
> 错误例子
```html
				<li v-for="(item,index) in list"  :key="index">
					{{ index }} = {{ item.key1 }}
					<input type="text"></input>
					<button @click="onDelete(index)">delete</button>
				</li>
```

> 正确例子
```html
				<li v-for="(item,index) in list" :key="item.key1">
					{{ index }} = {{ item.key1 }}
					<input type="text"></input>
					<button @click="onDelete(index)">delete</button>

				</li>
```

2. 可通过给状态组件加上数据绑定，就可避免就地复用的错误行为
```html
				<li v-for="(item,index) in list" >
					{{ index }} = {{ item.key1 }}
					<input type="text" :value="item.key1"></input>
					<button @click="onDelete(index)">delete</button>
				
				</li>
```

### 注意列表循环下，如果input采用:value指令进行初始赋值,你修改了input值，在删除数组数据后，触发dom响应，修改的值会恢复成初始值
![[20220806180500.gif]]
```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script src="../vue.js"></script>
	</head>
	<body>
		<div id="app">
			<ul>
				<li v-for="(item,index) in list">
					{{ index }} = {{ item.key1 }}
					<input type="text" :value="item.key1"></input>
					<button @click="onDelete(index)">delete</button>

				</li>
			</ul>
			<ul>
				<li v-for="(item,key) in object">
					{{ key }} ：{{ item }}
				</li>
			</ul>
		</div>
	</body>
	<script>
		var vm = new Vue({
			el: '#app',
			data: {
				list: [{
						'key1': "value1"
					},
					{
						'key1': "value2"
					},
					{
						'key1': "value3"
					}
				],
				object: {
					'key3': "value5",
					"key4": "value6"
				}
			},
			methods:{
				onDelete: function(index){
					vm.list.splice(index, 1);
				}
			}
		});
		
	</script>
</html>
```


#  事件绑定
![[20220807115700.gif]]
```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script src="../vue.js"></script>
	</head>
	<body>
		<div id="app">
			<button v-on:click="counter += 1">直接在指令中写js：{{ counter }}</button>
			<br />
			<button v-on:click="showName">绑定function：{{ name }}</button>
			<br />
			<button v-on:click="sourceEvent($event)">内联JavaScript调用function，原生event对象(使用$,看控制台输出){{ eventStr }}</button>
		</div>
	</body>
	<script>
		var vm = new Vue({
			el: '#app',
			data: {
				counter: 0,
				name: 'hello',
				oldName: '',
				eventStr: null
			},
			methods: {
				showName: function() {
					var oldName = this.oldName;
					var showName = '';
					if (oldName != '') {
						showName = oldName;
						oldName = this.name;
					} else {
						showName = 'vue';
						oldName = this.name;
					}

					this.name = showName;
					this.oldName = oldName;
				},
				sourceEvent: function(e){
					console.log(e);
				}
			}
		});
	</script>
</html>
```

# 表单输入绑定（双向绑定）
![[20220807120700.gif]]
```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script src="../vue.js"></script>
	</head>
	<body>
		<div id="app">
			<input type="text" v-model="inputText" placeholder="text" />
			<input type="text" v-model="inputText" placeholder="text" />
			<p>{{ inputText }}</p>
			
			<textarea v-model="textArea"></textarea>
			<p>{{ textArea }}</p>
			
			<!-- 多选框，存储的是数组 -->
			<div style="margin-top:20px;">
				<input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
				<label for="jack">Jack</label>
				<input type="checkbox" id="john" value="John" v-model="checkedNames">
				<label for="john">John</label>
				<input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
				<label for="mike">Mike</label>
				<br>
				<span>Checked names: {{ checkedNames }}</span>
			</div>
			
			<!-- 单选框，存储的是单个文本 -->
			<div style="margin-top:20px;">
				<input type="radio" id="one" value="One" v-model="picked">
				<label for="one">One</label>
				<br>
				<input type="radio" id="two" value="Two" v-model="picked">
				<label for="two">Two</label>
				<br>
				<span>Picked: {{ picked }}</span>
			</div>
			
			<button @click="submit">提交</button>
		</div>
	</body>
	<script>
		var vm = new Vue({
			el: '#app',
			data: {
				inputText: "inputText",
				textArea: "textArea",
				checkedNames:["Jack","Mike"],
				picked: "Two",
				dataArray: ["1","2","3"],
				inputArray: []
			},
			methods: {
				submit: function(){
					console.log(this.checkedNames);
				}
			}
		});
	</script>
</html>

```

# 组件基础
## 局部组件



## 全局组件