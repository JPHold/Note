[TOC]

# 创建应用（第一步）
1. createApp(...)创建的实例为应用实例；
2. createApp(...)的对象参数为根组件
3. 在应用实例上配置选项。如全局异常捕获、组件注册（**必须在mount之前完成配置**）。[API 参考](https://cn.vuejs.org/api/application.html)
4. mount()挂载应用，挂载到某个容器上，参数可以是DOM元素或CSS选择器字符串
5. 根组件的内容被渲染到容器元素中，但容器本身不会作为应用的一部分
```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="importmap">
			{
		    "imports": {
		      "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
		    }
		  }
		</script>
	</head>
	<body>
		<div id="app">{{message}}</div>
		<script type="module">
			import {
				createApp
			} from 'vue';

			createApp({
				data() {
					return {
						message: 'Hello Vue!'
					}
				}
			}).mount('#app')
		</script>
	</body>
</html>

```

6. 多个应用实例
> 适用于在一个页面上，想对不同部分，采用不同配置、资源隔离的策略
```html
const app1 = createApp({
  /* ... */
})
app1.mount('#container-1')

const app2 = createApp({
  /* ... */
})
app2.mount('#container-2')

```

**注意：**
1. 当采用单文件组件定义根组件时，如果定义了`<template>`，则容器的innerHTML会被覆盖

# 特性

| 特性             | 描述                                                                                                                                                                                                     | 注意 |
| ---------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---- |
| v-html           | 响应式作为元素的内容（innerHTML）；纯html，数据绑定失效；**请在安全可信环境下使用v-html，不要使用用户提供的html内容，会造成[XSS 漏洞](https://en.wikipedia.org/wiki/Cross-site_scripting)**；[[#v-html]] |      |
| v-bind           | 在元素上响应式绑定原生属性，支持单属性和绑定多个属性；支持表达式中使用[部分全局对象](https://github.com/vuejs/core/blob/main/packages/shared/src/globalsWhitelist.ts#L3)；可以将想用的原生对象、自定义对象加入进去：[`app.config.globalProperties`](https://cn.vuejs.org/api/application.html#app-config-globalproperties)；缩写：`:`；[[#v-bind]]                                                                                                                             |      |
| javascript表达式 | `{{}}`和以`v-`开头的指令，都可以使用；只支持单一表达式、函数调用                                                                                                                                         |      |
| 响应式                 | 1. 访问数据、修改数据都能反馈到DOM上，DOM的操作也会反馈到数据上，双向的。原理是[JavaScript Proxy](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)<br>2. 创建响应式变量、对象；创建响应式对象有[深层对象](https://cn.vuejs.org/api/reactivity-core.html#reactive)（支持深层响应）和[浅层对象](https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactivev) <br>3.**数据更改，并不是马上同步更新到组件上，而是缓存起来，等下次更新周期，所以在更新周期之前，同个数据多次更改，最终只会更新组件一次**<br>4.nextTick()监听DOM更新完毕<br>5. 对同个对象，创建多次响应式对象，只会复用同个响应式对象实例<br>6. 深层响应式对象，其嵌套对象也是响应式对象<br>ref()解决了reactive()的问题：支持所有类型（基础类型、对象类型）的数据作为响应式对象；赋值、解构到本地变量或传递到函数汇总而不失去响应                                                                                                                                                                                                        |      |


| [ref函数](https://cn.vuejs.org/api/reactivity-core.html#ref) | 定义响应式变量                        |                                                                                                                                                                                                          |      |
| [模板引用：ref函数和ref属性](https://cn.vuejs.org/guide/essentials/template-refs.html#function-refs) | 获取html元素，手动修改dom的情况。用ref函数创建响应式变量，然后在html元素指定ref属性值为该变量名。[[#模板引用]]                                                                                           |      |
| [侦听器：watch](https://cn.vuejs.org/guide/essentials/watchers.html)                                 | 监听ref实例，新值不是ref实例，自动帮我们解构了                                                                                                                                                           |      |
| 插槽：slot                                                                                           | 父组件添加自定义的html内容到子组件；`<slot>`的html内容是默认值；[[#插槽：slot]]                                                                                                                          |      |

## 模板引用
[官方例子](https://cn.vuejs.org/tutorial/#step-9)
App.vue
通过.value获取到的，其实是原生html dom元素实例，跟之前原生操作一样

```js
<script setup>
import { ref,onMounted } from 'vue'

const textP = ref(null);
  
  onMounted(()=>{
    textP.value.textContent = 'onMounted';
  });
  
</script>

<template>
  //ref属性值必须与ref函数返回的变量名一致
  <p ref="textP">hello</p>
</template>
```

## 侦听器
[官方例子](https://cn.vuejs.org/tutorial/#step-10)
监听todoId的变化，然后重新请求，并将相应结果显示在pre元素上
```js
<script setup>
import { ref,watch } from 'vue'

const todoId = ref(1)
const todoData = ref(null)

async function fetchData() {
  todoData.value = null
  const res = await fetch(
    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
  )
  todoData.value = await res.json()
}

fetchData();

//newTodoId不是ref实例，而是值
watch(todoId, (newTodoId) =>{
  fetchData();
});  
  
</script>

<template>
  <p>Todo id: {{ todoId }}</p>
  <button @click="todoId++">Fetch next todo</button>
  <p v-if="!todoData">Loading...</p>
  <pre v-else>{{ todoData }}</pre>
</template>
```

## 插槽：slot
ChildComp.vue
```html
<template>
  <slot>Fallback content</slot>
</template>
```

App.vue
```html
<script setup>
import { ref } from 'vue'
import ChildComp from './ChildComp.vue'

const msg = ref('from parent')
</script>

<template>
  <ChildComp>
    <p>
      你好slot插槽
    </p></ChildComp>
</template>
```

## v-html
```html

<p>Using text interpolation: {{ rawHtml }}</p>
<p>Using v-html directive: <span v-html="rawHtml"></span></p>

```

![[Pasted image 20230222140658.png]]

## v-bind

### 单属性绑定
```html
<div :id="dynamicId"></div>

<!-- 布尔型属性，属性值为空或true，则隐藏；为false则属性消失 -->
<button :disabled="isButtonDisabled">Button</button>
```

### 多属性绑定
不指定具体属性即可
```html
const objectOfAttrs = {
  id: 'container',
  class: 'wrapper'
}

<div v-bind="objectOfAttrs"></div>


```

### 动态属性
使用`[]`包裹，**不要使用大写，浏览器会转成小写**
```html

<a v-bind:[attributeName]="url"> ... </a>
<!-- 简写 -->
<a :[attributeName]="url"> ... </a>

<a v-on:[eventName]="doSomething"> ... </a>
<!-- 简写 -->
<a @[eventName]="doSomething">

```


## 响应式

创建响应式变量、对象；创建响应式对象有深层对象和浅层对象
```html
<!-- 变量 -->
<script setup>
import { ref } from 'vue'

const count = ref(0)

function increment() {
  count++
}
</script>

<template>
  <button @click="increment">
    {{ count }}
  </button>
</template>

```

```html
<!-- 深层对象 -->
<script setup>
import { reactive } from 'vue'

const state = reactive({ count: 0 })

function increment() {
  state.count++
}
</script>

<template>
  <button @click="increment">
    {{ state.count }}
  </button>
</template>

```

想知道DOM更新完毕，可在数据更改后，注册异步监听事件
```js
import { nextTick } from 'vue'

function increment() {
  state.count++;
  //紧跟着数据更改之后
  nextTick(() => {
    // 访问更新后的 DOM
  })
}

```

深层响应
```js
import { reactive } from 'vue'

const obj = reactive({
  nested: { count: 0 },
  arr: ['foo', 'bar']
})

function mutateDeeply() {
  // 以下都会按照期望工作
  obj.nested.count++
  obj.arr.push('baz')
}
```

浅层响应：只有根级别的属性才具备响应式，如果该属性是个对象（List、Map）都不是响应式的
```js
<script setup>
import { shallowReactive,isReactive } from 'vue'

defineProps({
  msg: String
})

const state = shallowReactive({count:0, obj:{count:0}});

let isReactiveResult = isReactive(state.obj);
console.log('----' + isReactiveResult); // false

//改变状态
state.count++; //响应式
state.obj.count++; //非响应式

</script>
```

对同个对象，创建多次响应式对象，只会复用同个响应式对象实例
```js
<script setup>
import { reactive } from 'vue'

let raw = {};
let proxy = reactive(raw)

// 在同一个对象上调用 reactive() 会返回相同的代理
console.log(reactive(raw) === proxy) // true

// 在一个代理上调用 reactive() 会返回它自己
console.log(reactive(proxy) === proxy) // true

</script>
```

深层响应式对象，其嵌套对象也是响应式对象
```js
<script setup>
import { reactive } from 'vue'

const proxy = reactive({})

//即使raw不是通过reactive创建出来的响应式对象，因proxy是，自动为响应式对象
const raw = {}
proxy.nested = raw

console.log(proxy.nested === raw) // false


</script>
```

reactive的局限性：
1. 仅对对象类型有效（对象、数组和 `Map`、`Set` 这样的[集合类型](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects#%E4%BD%BF%E7%94%A8%E9%94%AE%E7%9A%84%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1)），对基础类型无效
2. 一个对象就对应一个引用，不要覆盖引用，不然之前的响应式对象会失效，丢失响应式连接
```js
let state = reactive({ count: 0 })

// 上面的引用 ({ count: 0 }) 将不再被追踪（响应性连接已丢失！）
state = reactive({ count: 1 })

```

3. 将响应式对象的属性赋值到本地变量、或解构到本地变量、传参到函数中，都不会响应式
```js
const state = reactive({ count: 0 })

// n 是一个局部变量，同 state.count
// 失去响应性连接
let n = state.count
// 不影响原始的 state
n++

// count 也和 state.count 失去了响应性连接
let { count } = state
// 不会影响原始的 state
count++

// 该函数接收一个普通数字，并且
// 将无法跟踪 state.count 的变化
callSomeFunction(state.count)
```

ref()解决了reactive()的问题：支持所有类型（基础类型、对象类型）的数据作为响应式对象；赋值、解构到本地变量或传递到函数汇总而不失去响应。使用value属性访问源数据
```js
//基本类型
const count = ref(0)

console.log(count) // { value: 0 }
console.log(count.value) // 0

count.value++
console.log(count.value) // 1

```

```js
//对象类型
const obj = {
  foo: ref(1),
  bar: ref(2)
}

// 该函数接收一个 ref
// 需要通过 .value 取值
// 但它会保持响应性
callSomeFunction(obj.foo)

// 仍然是响应式的
const { foo, bar } = obj

```