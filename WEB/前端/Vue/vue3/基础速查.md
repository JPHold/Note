[TOC]

# 创建应用（第一步）
1. createApp(...)创建的实例为应用实例；
2. createApp(...)的对象参数为根组件
3. 在应用实例上配置选项。如全局异常捕获、组件注册（**必须在mount之前完成配置**）。[API 参考](https://cn.vuejs.org/api/application.html)
4. mount()挂载应用，挂载到某个容器上，参数可以是DOM元素或CSS选择器字符串
5. 根组件的内容被渲染到容器元素中，但容器本身不会作为应用的一部分
```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="importmap">
			{
		    "imports": {
		      "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
		    }
		  }
		</script>
	</head>
	<body>
		<div id="app">{{message}}</div>
		<script type="module">
			import {
				createApp
			} from 'vue';

			createApp({
				data() {
					return {
						message: 'Hello Vue!'
					}
				}
			}).mount('#app')
		</script>
	</body>
</html>

```

6. 多个应用实例
> 适用于在一个页面上，想对不同部分，采用不同配置、资源隔离的策略
```html
const app1 = createApp({
  /* ... */
})
app1.mount('#container-1')

const app2 = createApp({
  /* ... */
})
app2.mount('#container-2')

```

**注意：**
1. 当采用单文件组件定义根组件时，如果定义了`<template>`，则容器的innerHTML会被覆盖

# 特性
| 特性                                                                               | 描述                                                                                                           | 注意 |     |
| ---------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- | ---- | --- |
| [ref函数](https://cn.vuejs.org/api/reactivity-core.html#ref)                       | 定义响应式变量                                                                                                 |      |     |
| [模板引用：ref函数和ref属性](https://cn.vuejs.org/guide/essentials/template-refs.html#function-refs) | 获取html元素，手动修改dom的情况。用ref函数创建响应式变量，然后在html元素指定ref属性值为该变量名。[[#模板引用]] |      |     |
| [侦听器：watch](https://cn.vuejs.org/guide/essentials/watchers.html)                                                                                   | 监听ref实例，新值不是ref实例，自动帮我们解构了                                                                                                               |      |     |
| 插槽：slot | 父组件添加自定义的html内容到子组件；`<slot>`的html内容是默认值；[[#插槽：slot]] |      |     |

## 模板引用
[官方例子](https://cn.vuejs.org/tutorial/#step-9)
App.vue
通过.value获取到的，其实是原生html dom元素实例，跟之前原生操作一样

```js
<script setup>
import { ref,onMounted } from 'vue'

const textP = ref(null);
  
  onMounted(()=>{
    textP.value.textContent = 'onMounted';
  });
  
</script>

<template>
  //ref属性值必须与ref函数返回的变量名一致
  <p ref="textP">hello</p>
</template>
```

## 侦听器
[官方例子](https://cn.vuejs.org/tutorial/#step-10)
监听todoId的变化，然后重新请求，并将相应结果显示在pre元素上
```js
<script setup>
import { ref,watch } from 'vue'

const todoId = ref(1)
const todoData = ref(null)

async function fetchData() {
  todoData.value = null
  const res = await fetch(
    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
  )
  todoData.value = await res.json()
}

fetchData();

//newTodoId不是ref实例，而是值
watch(todoId, (newTodoId) =>{
  fetchData();
});  
  
</script>

<template>
  <p>Todo id: {{ todoId }}</p>
  <button @click="todoId++">Fetch next todo</button>
  <p v-if="!todoData">Loading...</p>
  <pre v-else>{{ todoData }}</pre>
</template>
```

## 插槽：slot
ChildComp.vue
```html
<template>
  <slot>Fallback content</slot>
</template>
```

App.vue
```html
<script setup>
import { ref } from 'vue'
import ChildComp from './ChildComp.vue'

const msg = ref('from parent')
</script>

<template>
  <ChildComp>
    <p>
      你好slot插槽
    </p></ChildComp>
</template>
```